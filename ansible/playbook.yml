# --- PLAY 1: Using role 'docker' ---
name: Deploy cloud-1 compose stack   # logs: header msg for Ansible logs)
hosts: web                           # Target group of hosts defined in inventory (the "web" group)
become: true                         # Run tasks with sudo/root privileges
vars_files:                          # External variable files to import
  - variables.yml                         # Load additional variables from vars.yml
roles:                               # Use predefined Ansible roles for modular automation
  - docker                           # Apply the role named 'docker' (found under roles/docker)
#minimal ref                         # Just a comment line

# --- PLAY 2: Explicit bootstrap tasks ---
- name: Cloud-1 bootstrap (Ubuntu target)   # logs: Second play -> targets Ubuntu hosts for initial setup
  hosts: all                                # Run on all inventory hosts
  become: true                              # Run tasks as sudo
  vars:                                     # Define play-specific variables
    repo_url: "https://github.com/ychun816/cloud-1.git"  # Git repo to clone app from
    app_dir: /opt/cloud-1                                # Directory where the app will live

  tasks:                                    # Sequence of operations

  #update cashe
    - name: Update apt cache                # logs: Refresh Ubuntu package index
      apt:
        update_cache: yes                   # = "apt-get update"
        cache_valid_time: 3600              # Skip update if cache is younger than 1 hour

  #install prerequisites
    - name: Install prerequisites           # logs: Install required system packages
      apt:
        name: [apt-transport-https, ca-certificates, curl, gnupg, lsb-release, python3-apt, ufw]
        state: present                      # Ensure they are installed

  #install docker 
    - name: Install Docker (official repo)  # Add Docker’s GPG key for package validation
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
      register: docker_key                  # Save the task result into variable “docker_key”

  #install docker
    - name: Add Docker apt repo             # Add Docker’s official repository to apt sources
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_lsb.codename }} stable"
        state: present

  #install docker components
    - name: Install docker-ce, docker-ce-cli, containerd.io  # Install Docker components
      apt:
        name: [docker-ce, docker-ce-cli, containerd.io]
        state: present
        update_cache: yes

    - name: Ensure docker group exists and add ansible user  # Create docker group if missing
      group:
        name: docker
        state: present

    - name: Install docker-compose plugin via pip (or use apt)  # Install docker-compose
      pip:
        name: docker-compose
        state: present
      become: true

    - name: Clone project repo              # Pull your app code from GitHub
      git:
        repo: "{{ repo_url }}"
        dest: "{{ app_dir }}"
        version: main                       # Checkout main branch
        force: yes                          # Overwrite local changes if repo exists

    - name: Allow SSH, HTTP, HTTPS in UFW   # Configure firewall rules
      ufw:
        rule: allow
        port: "{{ item }}"                  # Allow ports in the loop below
      loop: [22, 80, 443]                   # Apply for SSH (22), HTTP (80), HTTPS (443)

#ssh hardening -> more secure ssh config -> Strongly recommended for production servers, optional for local testing.
    - name: Disable root password login in sshd_config  # Harden SSH configuration
      lineinfile:
        path: /etc/ssh/sshd_config          # File to edit
        regexp: '^PermitRootLogin'          # Find the line starting with PermitRootLogin
        line: 'PermitRootLogin no'          # Replace with “no”
        state: present
        backup: yes                         # Backup file before editing

    - name: Restart ssh                     # Restart SSH service to apply new config
      service:
        name: ssh
        state: restarted

    - name: Create systemd service to run docker compose (example)  # Create custom systemd unit
      copy:
        dest: /etc/systemd/system/cloud-1.service  # Path of the service unit
        content: |                                 # Inline file content (multiline)
          [Unit]
          Description=Cloud-1 docker-compose
          After=network.target docker.service
          Requires=docker.service

          [Service]
          Type=oneshot
          RemainAfterExit=yes
          WorkingDirectory={{ app_dir }}/compose
          ExecStart=/usr/bin/docker compose up -d
          ExecStop=/usr/bin/docker compose down
          TimeoutStartSec=0

          [Install]
          WantedBy=multi-user.target
      notify: daemon-reload                    # Trigger handler to reload systemd

## 
  handlers:                                   # Handlers are triggered by notify
    - name: daemon-reload
      command: systemctl daemon-reload        # Reload systemd to recognize new service




### NOTES ###

# In Ansible, a playbook can contain multiple plays.
# Each play targets a specific group of hosts and defines what to do with them.
# Ansible follows an idempotent + step-by-step philosophy:
# 1. Each task should do one atomic thing.
# 2. If something fails, you know exactly which step.
# 3. You can re-run it safely — it’ll skip what’s already done.



# Why Play 1 has name: (no dash)	The very first line in YAML (no preceding -) defines a single dictionary (one play).
# Why Play 2 starts with - name:	A YAML list begins with -. This means the playbook can hold multiple plays in sequence, and each is an item in that list.
# Playbook
# │
# ├─ Play 1 → uses "docker" role
# └─ Play 2 → manual setup tasks


# roles:
#   - docker
# => This means: “Run all the tasks from the role named docker on the target hosts.”
# roles/
#  └── docker/
#      ├── tasks/
#      │   └── main.yml   ← Ansible automatically looks for a folder like this, these tasks are executed
#      ├── vars/
#      ├── templates/
#      └── files/


# rule: allow
# port: "{{ item }}"
# loop: [22, 80, 443]
# why loop? => Instead of repeating 3 tasks, you define one task and iterate over a list.
# => This means: “For each port in the list (22, 80, 443), create a UFW rule to allow traffic on that port.”
# | Port    | Protocol | Purpose                                  |
# | ------- | -------- | ---------------------------------------- |
# | **22**  | SSH      | Remote access (Ansible needs this open!) |
# | **80**  | HTTP     | For web traffic (WordPress / Nginx)      |
# | **443** | HTTPS    | For secure web traffic (SSL)             |





# | # | Concept               | Meaning / Function                  | Analogy                         |
# | - | --------------------- | ----------------------------------- | ------------------------------- |
# | 1 | Play 1 vs Play 2      | Independent plays executed in order | Two chapters in one script      |
# | 2 | `roles: - docker`     | Runs tasks from role `docker`       | Import and execute a module     |
# | 3 | Many Docker tasks     | One step = one operation            | Lego blocks for clarity         |
# | 4 | Loop 22/80/443        | Allow SSH/HTTP/HTTPS                | Firewall safety                 |
# | 5 | SSH hardening         | Disable root login                  | Security best practice          |
# | 6 | Inline file content   | Embed file content in YAML          | Write file directly in code     |
# | 7 | `notify` → `handlers` | Conditional callback                | “Only run if needed” automation |
##############